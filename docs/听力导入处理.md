# 听力内容快速导入处理指南

**版本**: 1.0
**日期**: 2025-10-25
**目的**: 支持 Excel/CSV 批量导入听力内容，快速扩展内容库
**核心流程**: Excel 上传 → 验证 → 音频处理 → 入库 → 发布

---

## 📋 目录

1. [Excel 模板规范](#excel-模板规范)
2. [后端处理流程](#后端处理流程)
3. [实现代码](#实现代码)
4. [错误处理](#错误处理)
5. [性能优化](#性能优化)

---

## Excel 模板规范

### 列定义

```
A列: 话题 (Topic)
B列: 难度 (Level)
C列: 标题 (Title)
D列: 时长(秒) (Duration)
E列: 音频URL (AudioUrl)
F列: 文本内容 (Transcript)
G列: 中文翻译 (Translation)
H列: 内容类型 (ContentType)
I列: 关键词汇 (Keywords) - 可选
J列: 摘要 (Summary) - 可选
```

### 示例数据

```
话题          | 难度  | 标题         | 时长(秒) | 音频URL                   | 文本内容                  | 中文翻译           | 内容类型   | 关键词汇            | 摘要
───────────────┼──────┼──────────────┼──────────┼──────────────────────────┼──────────────────────┼────────────────┼────────┼────────────────┼──────────
日常生活      | 初级 | 早上的问候    | 120      | https://oss.../audio1.mp3 | Good morning...      | 早上好...      | dialogue | greeting,morning | 两个人早上打招呼
日常生活      | 初级 | 咖啡店点餐    | 180      | https://oss.../audio2.mp3 | I would like...      | 我想要...      | dialogue | coffee,order     | 顾客在咖啡店点餐
科技创新      | KET  | 手机发展史    | 240      | https://oss.../audio3.mp3 | The smartphone...    | 智能手机...    | narrative| technology,phone | 讲述手机的发展历史
自然科学      | PET  | 生态系统      | 300      | https://oss.../audio4.mp3 | An ecosystem is...    | 生态系统是...  | narrative| ecosystem,nature | 讲解生态系统的概念
```

### 数据验证规则

| 列 | 必填 | 有效值 | 示例 |
|----|------|---------|------|
| 话题 | 是 | 日常生活/科技创新/历史文化/自然科学/社会文化/哲学思辨 | 日常生活 |
| 难度 | 是 | 初级/KET/PET | KET |
| 标题 | 是 | 任意字符串，长度 1-200 | 早上的问候 |
| 时长 | 否 | 1-3600 (秒) | 120 |
| 音频URL | 是 | 有效的 HTTP/HTTPS URL | https://... |
| 文本内容 | 是 | 英文文本，长度 > 20 字符 | Good morning... |
| 中文翻译 | 是 | 中文文本，长度 > 10 字符 | 早上好... |
| 内容类型 | 否 | dialogue/narrative/discussion/interview | dialogue |
| 关键词汇 | 否 | 逗号分隔的词汇 | greeting,morning |
| 摘要 | 否 | 中文摘要文本 | 两个人早上打招呼 |

---

## 后端处理流程

### 整体流程图

```
┌─────────────────┐
│  用户上传 Excel  │
└────────┬────────┘
         │
         ▼
┌──────────────────┐
│  解析 Excel 文件  │ ← 使用 xlsx 库解析
│ (逐行读取数据)    │
└────────┬────────┘
         │
         ▼
┌──────────────────┐
│   逐行验证数据   │ ← 字段检查、格式校验
│ (生成错误报告)    │
└────────┬────────┘
         │
    ┌────┴────┐
    │ 有错误？ │
    └────┬────┘
         │
    ┌────▼─────┐         ┌─────────────────┐
    │    是     │────────▶│返回错误信息      │
    └──────────┘         │停止导入          │
                         └─────────────────┘
    ┌────▼─────┐
    │    否     │
    └────┬─────┘
         │
         ▼
┌──────────────────┐
│  下载音频文件    │ ← 验证 URL 有效性
│ (至本地临时目录) │
└────────┬────────┘
         │
         ▼
┌──────────────────┐
│  音频处理        │ ← 转码、提取信息
│ (生成标准格式)   │
└────────┬────────┘
         │
         ▼
┌──────────────────┐
│  上传至 OSS      │ ← 获取永久 URL
│ (替换音频URL)    │
└────────┬────────┘
         │
         ▼
┌──────────────────┐
│  数据入库        │ ← 批量插入数据库
│ (事务保证一致性) │
└────────┬────────┘
         │
         ▼
┌──────────────────┐
│  成功完成        │
│ (返回导入统计)   │
└──────────────────┘
```

### 处理步骤详解

**Step 1: 解析 Excel**
- 使用 `xlsx` 库读取文件
- 校验列标题是否符合规范
- 逐行读取数据

**Step 2: 数据验证**
- 必填字段检查
- 数据类型转换 (如 Duration 转 number)
- 格式校验 (如 URL 格式、蓝斯值范围)
- 生成详细错误报告

**Step 3: 音频处理**
- 验证音频 URL 可达性
- 下载音频文件至临时目录
- 使用 FFmpeg 转码为标准格式 (mp3, 48kHz)
- 生成音频元数据 (时长、字节数等)

**Step 4: 上传至 OSS**
- 上传处理后的音频至阿里云 OSS
- 获取公开 URL (长期有效)
- 替换原 URL

**Step 5: 数据入库**
- 事务开启
- 批量插入 ListeningContent 表
- 插入相关子表数据
- 事务提交

---

## 实现代码

### 1. 上传接口定义

**controller/listening.controller.ts**:

```typescript
import {
  Controller,
  Post,
  UseInterceptors,
  UploadedFile,
  BadRequestException,
  Req,
  Query,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { Request } from 'express';
import { ListeningService } from '../services/listening.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { UseGuards } from '@nestjs/common';

@Controller('api/listening')
export class ListeningController {
  constructor(private listeningService: ListeningService) {}

  @Post('batch-import')
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(FileInterceptor('file'))
  async batchImport(
    @UploadedFile() file: Express.Multer.File,
    @Req() req: Request,
    @Query('skipValidation') skipValidation: boolean = false,
  ) {
    if (!file) {
      throw new BadRequestException('请选择 Excel 或 CSV 文件');
    }

    // 验证文件类型
    const allowedMimes = [
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-excel',
      'text/csv',
    ];

    if (!allowedMimes.includes(file.mimetype)) {
      throw new BadRequestException(
        '仅支持 Excel (.xlsx, .xls) 或 CSV 文件',
      );
    }

    // 验证文件大小 (最多 10MB)
    if (file.size > 10 * 1024 * 1024) {
      throw new BadRequestException('文件大小不能超过 10MB');
    }

    const userId = req.user.id;

    // 启动异步导入
    const importId = await this.listeningService.startBatchImport(
      file.buffer,
      userId,
      skipValidation,
    );

    return {
      code: 0,
      data: {
        importId,
        status: 'processing',
        message: '正在处理，预计 2-5 分钟完成',
        progressUrl: `/api/listening/batch-import/${importId}/progress`,
      },
    };
  }

  @Get('batch-import/:importId/progress')
  @UseGuards(JwtAuthGuard)
  async getImportProgress(@Param('importId') importId: string) {
    const progress = await this.listeningService.getImportProgress(importId);
    return {
      code: 0,
      data: progress,
    };
  }
}
```

### 2. 核心服务

**services/listening.service.ts**:

```typescript
import { Injectable, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../database/prisma.service';
import * as xlsx from 'xlsx';
import * as fs from 'fs';
import * as path from 'path';
import axios from 'axios';
import { execSync } from 'child_process';

interface ListeningRow {
  topic: string;
  level: string;
  title: string;
  duration?: number;
  audioUrl: string;
  transcript: string;
  translation: string;
  contentType?: string;
  keywords?: string;
  summary?: string;
}

interface ValidationError {
  rowNumber: number;
  error: string;
  title?: string;
}

interface ImportProgress {
  importId: string;
  status: 'processing' | 'completed' | 'failed';
  totalRows: number;
  successCount: number;
  failureCount: number;
  pendingCount: number;
  progress: number;
  errors: ValidationError[];
  completedAt?: Date;
}

@Injectable()
export class ListeningService {
  private importProgress: Map<string, ImportProgress> = new Map();
  private tempDir = path.join(process.cwd(), 'temp', 'listening');

  constructor(private prisma: PrismaService) {
    // 确保临时目录存在
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }
  }

  async startBatchImport(
    fileBuffer: Buffer,
    userId: string,
    skipValidation: boolean = false,
  ): Promise<string> {
    const importId = `import_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // 初始化进度跟踪
    this.importProgress.set(importId, {
      importId,
      status: 'processing',
      totalRows: 0,
      successCount: 0,
      failureCount: 0,
      pendingCount: 0,
      progress: 0,
      errors: [],
    });

    // 异步执行导入
    this.processBatchImportAsync(fileBuffer, importId, userId, skipValidation);

    return importId;
  }

  private async processBatchImportAsync(
    fileBuffer: Buffer,
    importId: string,
    userId: string,
    skipValidation: boolean,
  ) {
    try {
      // 1. 解析 Excel
      const rows = this.parseExcel(fileBuffer);

      const progress = this.importProgress.get(importId);
      if (progress) {
        progress.totalRows = rows.length;
        progress.pendingCount = rows.length;
      }

      // 2. 验证数据
      const validationErrors = this.validateRows(rows);

      // 如果有错误且不跳过验证，停止导入
      if (validationErrors.length > 0 && !skipValidation) {
        if (progress) {
          progress.status = 'failed';
          progress.errors = validationErrors;
          progress.failureCount = validationErrors.length;
          progress.pendingCount = 0;
          progress.completedAt = new Date();
        }
        return;
      }

      // 3. 处理音频
      const processedRows = await this.processAudioFiles(
        rows,
        importId,
        progress,
      );

      // 4. 数据入库
      const insertedCount = await this.insertListeningContent(
        processedRows,
        userId,
        importId,
      );

      // 5. 更新进度
      if (progress) {
        progress.status = 'completed';
        progress.successCount = insertedCount;
        progress.pendingCount = 0;
        progress.progress = 100;
        progress.completedAt = new Date();
      }
    } catch (error) {
      const progress = this.importProgress.get(importId);
      if (progress) {
        progress.status = 'failed';
        progress.errors = [
          {
            rowNumber: 0,
            error: error.message || '未知错误',
          },
        ];
        progress.completedAt = new Date();
      }
      console.error(`Import ${importId} failed:`, error);
    }
  }

  private parseExcel(fileBuffer: Buffer): ListeningRow[] {
    try {
      const workbook = xlsx.read(fileBuffer, { type: 'buffer' });
      const worksheet = workbook.Sheets[workbook.SheetNames[0]];

      // 获取所有行
      const rows: ListeningRow[] = [];
      let rowIndex = 2; // 从第 2 行开始 (跳过标题)

      while (true) {
        const cellA = worksheet[`A${rowIndex}`];
        if (!cellA) break; // 到达空行，停止

        rows.push({
          topic: cellA.v || '',
          level: worksheet[`B${rowIndex}`]?.v || '',
          title: worksheet[`C${rowIndex}`]?.v || '',
          duration: parseInt(worksheet[`D${rowIndex}`]?.v) || undefined,
          audioUrl: worksheet[`E${rowIndex}`]?.v || '',
          transcript: worksheet[`F${rowIndex}`]?.v || '',
          translation: worksheet[`G${rowIndex}`]?.v || '',
          contentType: worksheet[`H${rowIndex}`]?.v || 'narrative',
          keywords: worksheet[`I${rowIndex}`]?.v || '',
          summary: worksheet[`J${rowIndex}`]?.v || '',
        });

        rowIndex++;
      }

      return rows;
    } catch (error) {
      throw new BadRequestException('Excel 文件格式错误: ' + error.message);
    }
  }

  private validateRows(rows: ListeningRow[]): ValidationError[] {
    const errors: ValidationError[] = [];

    const validTopics = [
      '日常生活',
      '科技创新',
      '历史文化',
      '自然科学',
      '社会文化',
      '哲学思辨',
    ];
    const validLevels = ['初级', 'KET', 'PET'];

    rows.forEach((row, idx) => {
      const rowNumber = idx + 2; // Excel 中的行号

      // 验证话题
      if (!validTopics.includes(row.topic)) {
        errors.push({
          rowNumber,
          error: `无效的话题: ${row.topic}，应为: ${validTopics.join('/')}`,
          title: row.title,
        });
      }

      // 验证难度
      if (!validLevels.includes(row.level)) {
        errors.push({
          rowNumber,
          error: `无效的难度: ${row.level}，应为: ${validLevels.join('/')}`,
          title: row.title,
        });
      }

      // 验证标题
      if (!row.title || row.title.trim().length === 0) {
        errors.push({
          rowNumber,
          error: '标题不能为空',
          title: row.title,
        });
      }

      // 验证音频 URL
      if (!row.audioUrl || !this.isValidUrl(row.audioUrl)) {
        errors.push({
          rowNumber,
          error: '无效的音频 URL',
          title: row.title,
        });
      }

      // 验证文本内容
      if (!row.transcript || row.transcript.trim().length < 20) {
        errors.push({
          rowNumber,
          error: '文本内容长度至少 20 字符',
          title: row.title,
        });
      }

      // 验证翻译
      if (!row.translation || row.translation.trim().length < 10) {
        errors.push({
          rowNumber,
          error: '中文翻译长度至少 10 字符',
          title: row.title,
        });
      }
    });

    return errors;
  }

  private async processAudioFiles(
    rows: ListeningRow[],
    importId: string,
    progress: ImportProgress | undefined,
  ): Promise<ListeningRow[]> {
    const processedRows: ListeningRow[] = [];

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];

      try {
        // 下载音频
        const audioPath = await this.downloadAudio(row.audioUrl, importId, i);

        // 转码为标准格式
        const processedAudioPath = await this.transcodeAudio(
          audioPath,
          importId,
          i,
        );

        // 上传至 OSS
        const ossUrl = await this.uploadToOss(
          processedAudioPath,
          `listening/${importId}/audio_${i}.mp3`,
        );

        // 替换 URL
        row.audioUrl = ossUrl;

        // 获取音频时长 (如果未提供)
        if (!row.duration) {
          row.duration = await this.getAudioDuration(processedAudioPath);
        }

        processedRows.push(row);

        // 更新进度
        if (progress) {
          progress.successCount++;
          progress.pendingCount--;
          progress.progress = Math.round(
            (progress.successCount / progress.totalRows) * 100,
          );
        }
      } catch (error) {
        console.error(`Failed to process audio for row ${i + 2}:`, error);
        // 继续处理下一行
      }
    }

    return processedRows;
  }

  private async downloadAudio(
    url: string,
    importId: string,
    index: number,
  ): Promise<string> {
    const filename = `audio_${index}_${Date.now()}.tmp`;
    const filepath = path.join(this.tempDir, importId, filename);

    // 确保目录存在
    fs.mkdirSync(path.dirname(filepath), { recursive: true });

    try {
      const response = await axios.get(url, {
        responseType: 'arraybuffer',
        timeout: 30000,
      });

      fs.writeFileSync(filepath, response.data);
      return filepath;
    } catch (error) {
      throw new Error(`下载音频失败: ${error.message}`);
    }
  }

  private async transcodeAudio(
    inputPath: string,
    importId: string,
    index: number,
  ): Promise<string> {
    const outputPath = path.join(
      this.tempDir,
      importId,
      `audio_${index}_processed.mp3`,
    );

    try {
      // 使用 FFmpeg 转码
      execSync(
        `ffmpeg -i "${inputPath}" -acodec libmp3lame -ab 128k -ar 48000 "${outputPath}"`,
        { stdio: 'pipe' },
      );

      // 删除原始文件
      fs.unlinkSync(inputPath);

      return outputPath;
    } catch (error) {
      throw new Error(`音频转码失败: ${error.message}`);
    }
  }

  private async getAudioDuration(audioPath: string): Promise<number> {
    try {
      const output = execSync(
        `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1:noval=0 "${audioPath}"`,
        { encoding: 'utf-8' },
      );

      return Math.round(parseFloat(output.trim()));
    } catch (error) {
      console.error('Failed to get audio duration:', error);
      return 0;
    }
  }

  private async uploadToOss(
    localPath: string,
    objectKey: string,
  ): Promise<string> {
    // 使用阿里云 OSS SDK 上传
    // 返回永久 URL
    // TODO: 实现 OSS 上传
    return `https://oss.example.com/${objectKey}`;
  }

  private async insertListeningContent(
    rows: ListeningRow[],
    userId: string,
    importId: string,
  ): Promise<number> {
    // 使用事务确保数据一致性
    const created = await this.prisma.$transaction(
      rows.map((row) =>
        this.prisma.listeningContent.create({
          data: {
            title: row.title,
            topic: row.topic,
            level: row.level,
            duration: row.duration,
            audioUrl: row.audioUrl,
            transcript: row.transcript,
            translation: row.translation,
            contentType: row.contentType || 'narrative',
            keywords: row.keywords,
            summary: row.summary,
            importBatchId: importId,
            importedBy: userId,
            importedAt: new Date(),
          },
        }),
      ),
    );

    return created.length;
  }

  private isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return url.startsWith('http://') || url.startsWith('https://');
    } catch {
      return false;
    }
  }

  getImportProgress(importId: string): ImportProgress {
    return (
      this.importProgress.get(importId) || {
        importId,
        status: 'failed',
        totalRows: 0,
        successCount: 0,
        failureCount: 0,
        pendingCount: 0,
        progress: 0,
        errors: [{ rowNumber: 0, error: '导入不存在' }],
      }
    );
  }
}
```

### 3. 数据库模型更新

**schema.prisma**:

```prisma
model ListeningContent {
  id              String @id @default(cuid())
  title           String
  topic           String  // 日常生活|科技创新|历史文化|自然科学|社会文化|哲学思辨
  level           String  // 初级|KET|PET
  duration        Int?    // 秒数
  audioUrl        String
  transcript      String  @db.Text
  translation     String  @db.Text
  contentType     String  @default("narrative")  // dialogue|narrative|discussion|interview
  keywords        String? // 逗号分隔
  summary         String? @db.Text

  // 导入元数据
  importBatchId   String?
  importedAt      DateTime?
  importedBy      String?

  // 关联
  listeningHistory ListeningHistory[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([topic])
  @@index([level])
  @@index([importBatchId])
}

model ListeningHistory {
  id                String @id @default(cuid())
  userId            String
  listeningContentId String
  listeningContent  ListeningContent @relation(fields: [listeningContentId], references: [id], onDelete: Cascade)

  listenCount       Int @default(1)
  totalListeningTime Int @default(0)  // 秒数
  completed         Boolean @default(false)
  completedAt       DateTime?
  lastListenAt      DateTime @default(now())

  playbackSpeed     Float @default(1.0)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, listeningContentId])
  @@index([userId])
}
```

---

## 错误处理

### 常见错误场景

| 场景 | 错误信息 | 处理方案 |
|------|--------|--------|
| 文件格式错误 | "仅支持 Excel 或 CSV 文件" | 检查文件类型 |
| 文件太大 | "文件大小不能超过 10MB" | 分批上传 |
| Excel 格式错误 | "Excel 文件格式错误" | 检查列标题和数据格式 |
| 话题无效 | "无效的话题: xxx" | 使用规定的 6 个话题 |
| URL 无效 | "无效的音频 URL" | 检查 URL 可达性 |
| 下载失败 | "下载音频失败: xxx" | 检查网络连接和 URL |
| 转码失败 | "音频转码失败: xxx" | 确保已安装 FFmpeg |
| OSS 上传失败 | "OSS 上传失败: xxx" | 检查 Access Key 配置 |

### 客户端错误处理

```typescript
// frontend/src/services/listening.ts

export const batchImportListening = async (file: File) => {
  try {
    const formData = new FormData();
    formData.append('file', file);

    const response = await axios.post(
      '/api/listening/batch-import',
      formData,
      {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      },
    );

    const importId = response.data.data.importId;

    // 开始轮询进度
    return pollImportProgress(importId);
  } catch (error) {
    if (error.response?.status === 400) {
      throw new Error(error.response.data.message);
    }
    throw new Error('导入失败，请重试');
  }
};

// 轮询导入进度
const pollImportProgress = async (importId: string) => {
  return new Promise((resolve, reject) => {
    const interval = setInterval(async () => {
      try {
        const response = await axios.get(
          `/api/listening/batch-import/${importId}/progress`,
        );
        const progress = response.data.data;

        if (progress.status === 'completed') {
          clearInterval(interval);
          resolve({
            success: true,
            successCount: progress.successCount,
            errorCount: progress.failureCount,
            errors: progress.errors,
          });
        } else if (progress.status === 'failed') {
          clearInterval(interval);
          reject(new Error(progress.errors[0]?.error || '导入失败'));
        }
      } catch (error) {
        clearInterval(interval);
        reject(error);
      }
    }, 2000); // 每 2 秒查询一次进度
  });
};
```

---

## 性能优化

### 1. 批量处理

```typescript
// 批量插入，减少数据库往返
const created = await this.prisma.$transaction(
  rows.map((row) =>
    this.prisma.listeningContent.create({ data: row }),
  ),
);
```

### 2. 并发处理音频

```typescript
// 使用 Promise.all 并发处理，而不是串行
const processAudioPromises = rows.map((row, idx) =>
  this.processAudioFile(row, importId, idx),
);

const results = await Promise.all(processAudioPromises);
```

### 3. 流式处理大文件

```typescript
// 对于大 Excel 文件，使用流式处理
import { createReadStream } from 'fs';

const workbook = xlsx.read(fileBuffer, {
  type: 'buffer',
  sheetStubs: false,
});
```

### 4. 音频预处理缓存

```typescript
// 缓存已转码的音频，避免重复处理
const audioCache = new Map<string, string>();

if (audioCache.has(audioUrl)) {
  row.audioUrl = audioCache.get(audioUrl);
} else {
  const processedUrl = await this.processAudio(audioUrl);
  audioCache.set(audioUrl, processedUrl);
  row.audioUrl = processedUrl;
}
```

---

**维护者**: 后端开发团队
**最后更新**: 2025-10-25
